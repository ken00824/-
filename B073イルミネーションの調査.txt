/*
B073:【キャンペーン問題】イルミネーションの調査
あなたは、並木道の木に電飾を施す仕事をしています。しかし、予算に限りがあるため使える電球の数に限りがあります。
全ての木に均等に電球を割り振るのは面白くないと考えたあなたは、木によって備え付ける電球の数を変えました。電球の数が少なく歩行が危険な区間があると困るので、ある木から別の木までの間に電球がいくつ備え付けられているか調査することにしました。

調査の結果、区間の木の電球の平均個数が、安全基準 M を満たしていない場合は、平均個数が安全基準を満たすように、その区間の木に均等に電球を追加します。ただし、追加する電球は安全の基準を満たすために必要最小限の個数に止めるようにします。また、安全の基準はその区間に備え付けられている電球の数の平均がいくつ以上という形で与えられます。

並木道の木の数、それぞれの木に備え付けられている電球の数および Q 個の電球の数を調べたい区間が与えられるので、全ての区間を調査して必要な電球を備え付けた後の並木道の状態を出力するプログラムを作成してください。ただし、調査および電球の追加は与えられた区間の順番に行うものとします。

入力例 1 では、以下のようになります。
図1

評価ポイント
10回のテストケースで、正答率、実行速度、メモリ消費量をはかり得点が決まります。
より早い回答時間で提出したほうが得点が高くなります。
複数のテストケースで正しい出力がされるか評価（+50点）
解答までの速さ評価（+50点）
入力される値
入力は以下のフォーマットで与えられます。

N M
A_1 A_2 ... A_N
Q
S_1 E_1
S_2 E_2
...
S_Q E_Q
・1 行目には、並木道に並ぶ木の本数を表す整数 N および区間の電球の平均個数が上回らなければならない数を表す整数 M が与えられます。
・2 行目には、それぞれの木にいくつ電球が装飾されているかを表す整数 A_i (1 ≦ i ≦ N) が半角スペース区切りで与えられます。
・3 行目には、電球の数を調べたい区間の数を表す整数 Q が与えられます。
・続く Q 行には、電球の数を調べたい区間の始点を表す整数 S_i、終点を表す整数 E_i (1 ≦ i ≦ Q) が半角スペース区切りで与えられます。
・入力は全部で 3 + Q 行からなり、末尾に改行が 1 つ入ります。

それぞれの値は文字列で標準入力から渡されます。標準入力からの値取得方法はこちらをご確認ください
期待する出力
全ての区間の調査及び電球の追加が終了した時点の木に備え付けられている電球の数を半角スペース区切りで出力してください。

末尾に改行を入れ、余計な文字、空行を含んではいけません。

条件
すべてのテストケースにおいて、以下の条件をみたします。

・1 ≦ N ≦ 1,000
・1 ≦ M ≦ 100
・1 ≦ A_i ≦ 100 (1 ≦ i ≦ N)
・1 ≦ Q ≦ 1,000
・1 ≦ S_i ≦ E_i ≦ N (1 ≦ i ≦ Q)
-------------------------------------------------------------------------------------------------------------------------------------------------*/
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int cnt,flag=0;
		float treeavg=0,treetotal=0;
		int tree[] = new int[1000];
		int rngs[] = new int[1000];
		int rnge[] = new int[1000];
		int num = scanner.nextInt();
		int safe = scanner.nextInt();
		for(int i=0; i<num; i++) {
			tree[i] = scanner.nextInt();
		}
		
		int rnum = scanner.nextInt();

		for(int i=0; i<rnum; i++) {
			rngs[i] = scanner.nextInt();
			rnge[i] = scanner.nextInt();
		}
		
		if(1<=num&&num<=1000
	     &&1<=safe&&safe<=1000
	     &&1<=rnum&&rnum<=1000) {
			
		}else {
			flag = 1;
		}
		
		for(int i=0; i<num; i++) {
			if(1<=tree[i]&&tree[i]<=100) {
				
			}else {
				flag = 1;
			}
		}
		
        for(int i=0; i<rnum; i++) {
			if(1<=rngs[i]&&rngs[i]<=rnge[i]&&rnge[i]<=num) {
				
			}else {
				flag = 1;
			}
		}
		
        if(flag == 0) {
        	for(int i=0; i<rnum; i++) {
    			cnt = 0;
    			for(int j=rngs[i]-1; j<=rnge[i]-1; j++) {
    				treetotal += tree[j];
    				cnt++;
    			}
    			treeavg = treetotal/cnt;
    			while(treeavg<safe) {
    				treeavg++;
    				for(int j=rngs[i]-1; j<=rnge[i]-1; j++) {
    					tree[j]++;
    				}
    			}
    			treetotal = 0;
    			treeavg = 0;

    		}

    		for(int i=0; i<num; i++) {
    			System.out.print(tree[i]);
    			if(i<num-1) {
    				System.out.print(" ");
    			}
    		}
        }
        
		scanner.close();
	}

}